---
import Main from "../../../layouts/Main.astro";
import { marked } from "marked";
import { FAILSAFE_SCHEMA, load } from "js-yaml";
import setupMarkdown from "../../../data/llm-tests/simple-tama-agentic-workflow-q1-2026/setup.md?raw";
import { simpleTamaQ12026Suites as suites } from "../../../data/llm-tests/simple-tama-agentic-workflow-q1-2026/suites";
import SimpleTamaFlow from "../../../components/llm-tests/simple-tama-flow.js";
import { summarizeLatencyScore } from "../../../utils/llm-tests/latency";
import { sumStepScores } from "../../../utils/llm-tests/scoring";

type SummaryTask = {
  id: number;
  score: number | null;
  insertedAtRaw: string;
  updatedAtRaw: string;
};

type SummaryTurn = {
  turn: number;
  tasks: SummaryTask[];
};

type SuiteScoreSummary = {
  suite: string;
  totalTurns: number;
  outputScoredTurns: number;
  latencyScoredTurns: number;
  outputScoreAvg: number | null;
  latencyScoreAvg: number | null;
};

const setupHtml = marked.parse(setupMarkdown);
const site = Astro.site ?? new URL("https://upmaru.com");
const pageImage = new URL(
  "/llm-tests/simple-tama-agentic-workflow-q1-2026.png",
  site,
).toString();

function normalizeScore(value: unknown): number | null {
  if (value === null || value === undefined) return null;
  const normalized = String(value).trim().toLowerCase();
  if (normalized.length === 0) return null;
  if (normalized === "pass") return 2;
  if (normalized === "partial") return 1;
  if (normalized === "fail") return 0;
  if (normalized === "0" || normalized === "1" || normalized === "2") {
    return Number(normalized);
  }
  return null;
}

function parseTimestampMicros(value: string) {
  const match = value.match(
    /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/,
  );
  if (!match) return null;

  const [, year, month, day, hour, minute, second, fraction = "0"] = match;
  const micros = Number(`${fraction}000000`.slice(0, 6));
  const milliseconds = Math.floor(micros / 1000);
  const remainingMicros = micros % 1000;

  const epochMilliseconds = new Date(
    Number(year),
    Number(month) - 1,
    Number(day),
    Number(hour),
    Number(minute),
    Number(second),
    Number(milliseconds),
  ).getTime();

  return epochMilliseconds * 1000 + remainingMicros;
}

function parseSummaryTurns(parsed: Record<string, unknown>): SummaryTurn[] {
  if (Array.isArray(parsed.turns)) {
    return parsed.turns
      .map((rawTurn, index) => {
        const turnRecord =
          rawTurn && typeof rawTurn === "object"
            ? (rawTurn as Record<string, unknown>)
            : {};
        const tasks = Array.isArray(turnRecord.tasks)
          ? turnRecord.tasks
              .filter(
                (task): task is Record<string, unknown> =>
                  Boolean(task) && typeof task === "object",
              )
              .map((task) => ({
                id: Number(task.id ?? 0),
                score: normalizeScore(task.score ?? task.result),
                insertedAtRaw: String(task.inserted_at ?? ""),
                updatedAtRaw: String(task.updated_at ?? ""),
              }))
          : [];

        return {
          turn: Number(turnRecord.turn ?? index + 1),
          tasks,
        };
      })
      .sort((a, b) => a.turn - b.turn);
  }

  const tasks = Array.isArray(parsed.tasks)
    ? parsed.tasks
        .filter(
          (task): task is Record<string, unknown> =>
            Boolean(task) && typeof task === "object",
        )
        .map((task) => ({
          id: Number(task.id ?? 0),
          score: normalizeScore(task.score ?? task.result),
          insertedAtRaw: String(task.inserted_at ?? ""),
          updatedAtRaw: String(task.updated_at ?? ""),
        }))
    : [];

  return [{ turn: Number(parsed.turn ?? 1), tasks }];
}

function averageAcrossTurns(values: number[], totalTurns: number) {
  if (totalTurns <= 0) return null;
  const total = values.reduce((sum, value) => sum + value, 0);
  return Number((total / totalTurns).toFixed(1));
}

function buildSuiteScoreSummary(rawYaml: string): SuiteScoreSummary {
  const parsed = load(rawYaml, { schema: FAILSAFE_SCHEMA }) as
    | Record<string, unknown>
    | undefined;
  if (!parsed || typeof parsed !== "object") {
    return {
      suite: "",
      totalTurns: 0,
      outputScoredTurns: 0,
      latencyScoredTurns: 0,
      outputScoreAvg: null,
      latencyScoreAvg: null,
    };
  }

  const turns = parseSummaryTurns(parsed);
  const outputScores: number[] = [];
  const latencyScores: number[] = [];

  for (const turn of turns) {
    const tasks = [...turn.tasks].sort((a, b) => a.id - b.id);

    const outputScopeTasks = tasks.filter(
      (task) => task.id >= 1 && task.id <= 5,
    );
    const hasAllOutputScores = [1, 2, 3, 4, 5].every((id) =>
      outputScopeTasks.some(
        (task) => task.id === id && typeof task.score === "number",
      ),
    );

    if (hasAllOutputScores) {
      const outputSummary = sumStepScores(outputScopeTasks, {
        fromStep: 1,
        toStep: 5,
      });
      outputScores.push(outputSummary.total);
    }

    const waitingDurations = tasks
      .filter((task) => task.id >= 1 && task.id <= 4)
      .map((task) => {
        const startMicros = parseTimestampMicros(task.insertedAtRaw);
        const endMicros = parseTimestampMicros(task.updatedAtRaw);
        if (!startMicros || !endMicros) return null;
        return { durationMicros: Math.max(endMicros - startMicros, 1) };
      })
      .filter((task): task is { durationMicros: number } => Boolean(task));

    const latencySummary = summarizeLatencyScore(waitingDurations);
    if (latencySummary) latencyScores.push(latencySummary.normalizedScore);
  }

  return {
    suite: String(parsed.suite ?? ""),
    totalTurns: turns.length,
    outputScoredTurns: outputScores.length,
    latencyScoredTurns: latencyScores.length,
    outputScoreAvg: averageAcrossTurns(outputScores, turns.length),
    latencyScoreAvg: averageAcrossTurns(latencyScores, turns.length),
  };
}

function formatOutOfTen(value: number | null) {
  if (value === null) return "-";
  return value.toFixed(1);
}

const llmTasks = [
  {
    name: "routing",
    description:
      "Classify the user request and route it to the correct workflow path.",
  },
  {
    name: "query-database",
    description:
      "Generate a valid database query from the request and available context.",
  },
  {
    name: "routing",
    description:
      "Route the chain output to the response stage that will produce user-facing output.",
  },
  {
    name: "create-artifact",
    description:
      "Build a structured artifact from results so the UI can render a useful view.",
  },
  {
    name: "stream-response",
    description:
      "Compose and stream the final response to the user with the generated artifact.",
  },
];

const suiteResultFiles = import.meta.glob(
  "/src/data/llm-tests/simple-tama-agentic-workflow-q1-2026/*/results.yml",
  {
    eager: true,
    query: "?raw",
    import: "default",
  },
) as Record<string, string>;

const suiteScoreBySlug = Object.entries(suiteResultFiles).reduce<
  Record<string, SuiteScoreSummary>
>((acc, [filePath, rawYaml]) => {
  const slugMatch = filePath.match(
    /simple-tama-agentic-workflow-q1-2026\/([^/]+)\/results\.yml$/,
  );
  const slug = slugMatch?.[1];
  if (!slug) return acc;
  acc[slug] = buildSuiteScoreSummary(rawYaml);
  return acc;
}, {});

const summaryRows = suites.map((suite) => {
  const score = suiteScoreBySlug[suite.slug];
  const outputScore = score?.outputScoreAvg ?? null;
  const latencyScore = score?.latencyScoreAvg ?? null;

  return {
    title: score?.suite || suite.title,
    href: `/llm-tests/simple-tama-agentic-workflow-q1-2026/${suite.slug}`,
    iconSrc: suite.iconSrc,
    iconAlt: suite.iconAlt || `${suite.title} icon`,
    outputScore,
    latencyScore,
    outputScoreText: formatOutOfTen(outputScore),
    latencyScoreText: formatOutOfTen(latencyScore),
    outputScoreSort: outputScore ?? -1,
    latencyScoreSort: latencyScore ?? -1,
    turnsText: score
      ? `${score.outputScoredTurns} output, ${score.latencyScoredTurns} latency`
      : "No results yet",
  };
});
---

<Main
  title="Simple Tama Agentic Workflow - Q1 2026 | Upmaru"
  description="LLM suite index for the Simple Tama Agentic Workflow test run in Q1 2026."
  image={pageImage}
>
  <div class="mx-auto flex w-full flex-col items-center px-6 pt-12 lg:pt-16">
    <a href="/" class="inline-flex">
      <img class="h-12 w-auto" src="/instellar-logo.png" alt="Upmaru" />
    </a>
    <p class="mt-2 text-xl font-semibold tracking-tight sm:text-2xl">Upmaru</p>
  </div>
  <section class="mx-auto max-w-6xl px-6 pb-24 pt-10 lg:pb-32 lg:pt-12">
    <div class="mb-10">
      <a
        href="/llm-tests/"
        class="text-sm font-semibold text-primary hover:underline"
        >&larr; Back to LLM Tests</a
      >
      <h1 class="mt-4 text-4xl font-bold tracking-tight sm:text-5xl">
        Simple Tama Agentic Workflow - Q1 2026
      </h1>
      <p class="mt-3 text-base-content/70">
        Baseline workflow that tests a model, or an ensemble of models, on its
        ability to navigate an agentic system. These tests cover tasks such as
        <code>classification</code>, <code>function calling</code>,{" "}
        <code>intent detection</code>, and other workflow behaviors to evaluate
        overall performance quality.
      </p>
      <p class="mt-2 text-base-content/70">
        Agentic systems favor smaller, faster models, so the benchmark starts
        with the fastest capable option and only moves up in model size or
        reasoning depth when a smaller variant fails.
      </p>
    </div>

    <div class="space-y-8">
      <section>
        <h2 class="text-2xl font-semibold">Setup</h2>
        <div class="prose prose-invert mt-3 max-w-none" set:html={setupHtml} />
      </section>

      <section>
        <h2 class="text-2xl font-semibold">Architecture</h2>
        <p class="mt-2 text-base-content/75">
          The following is the configured architecture of the workflow that the
          LLM will follow:
        </p>
        <div class="relative left-1/2 right-1/2 mt-6 -mx-[50vw] w-screen">
          <SimpleTamaFlow client:only="react" />
        </div>
        <h3 class="mt-8 text-xl font-semibold">LLM Tasks</h3>
        <p class="mt-2 text-base-content/75">
          These tasks correspond to the numbered LLM nodes in the architecture
          diagram.
        </p>
        <div class="mt-3 overflow-x-auto">
          <table class="table table-zebra">
            <thead>
              <tr>
                <th></th>
                <th>Name</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              {
                llmTasks.map((task, index) => (
                  <tr>
                    <th>{index + 1}</th>
                    <td class="font-mono font-semibold">{task.name}</td>
                    <td>{task.description}</td>
                  </tr>
                ))
              }
            </tbody>
          </table>
        </div>
      </section>

      <section>
        <h2 class="text-2xl font-semibold">Results</h2>
        <ul class="mt-4 grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
          {
            suites.map((suite) => (
              <li class="rounded-box border border-base-300 bg-base-100 p-5">
                <div class="flex h-full flex-col">
                  <div>
                    {suite.iconSrc && (
                      <img
                        src={suite.iconSrc}
                        alt={suite.iconAlt || `${suite.title} icon`}
                        class="mb-3 h-8 w-auto"
                        loading="lazy"
                      />
                    )}
                    <h3 class="text-xl font-semibold">
                      <a
                        href={`/llm-tests/simple-tama-agentic-workflow-q1-2026/${suite.slug}`}
                        class="hover:underline"
                      >
                        {suite.title}
                      </a>
                    </h3>
                    <p class="mt-1 text-base-content/75">{suite.description}</p>
                  </div>
                  <a
                    href={`/llm-tests/simple-tama-agentic-workflow-q1-2026/${suite.slug}`}
                    class="btn btn-primary btn-sm mt-4 self-start"
                  >
                    View Results
                  </a>
                </div>
              </li>
            ))
          }
        </ul>
      </section>

      <section>
        <h2 class="text-2xl font-semibold">Summary</h2>
        <p class="mt-2 text-base-content/75">
          Key findings and results summary in a single rankings table.
        </p>
        <div
          class="mt-4 overflow-x-auto rounded-box border border-base-content/5 bg-base-100"
        >
          <table class="table">
            <thead>
              <tr>
                <th></th>
                <th></th>
                <th>Model Test</th>
                <th>
                  <button
                    type="button"
                    class="btn btn-ghost btn-xs px-1 normal-case"
                    data-sort-key="outputScoreSort"
                    data-label="Output Score"
                  >
                    Output Score
                  </button>
                </th>
                <th>
                  <button
                    type="button"
                    class="btn btn-ghost btn-xs px-1 normal-case"
                    data-sort-key="latencyScoreSort"
                    data-label="Latency Score"
                  >
                    Latency Score
                  </button>
                </th>
                <th>Turns Scored</th>
              </tr>
            </thead>
            <tbody id="suite-summary-body">
              {
                summaryRows.map((row, index) => {
                  return (
                    <tr
                      data-output-score-sort={row.outputScoreSort}
                      data-latency-score-sort={row.latencyScoreSort}
                    >
                      <th>{index + 1}</th>
                      <td>
                        {row.iconSrc && (
                          <img
                            src={row.iconSrc}
                            alt={row.iconAlt}
                            class="h-5 w-auto"
                            loading="lazy"
                          />
                        )}
                      </td>
                      <td>
                        <a
                          href={row.href}
                          class="font-semibold hover:underline"
                        >
                          {row.title}
                        </a>
                      </td>
                      <td class="font-mono">{row.outputScoreText}</td>
                      <td class="font-mono">{row.latencyScoreText}</td>
                      <td class="text-sm text-base-content/75">
                        {row.turnsText}
                      </td>
                    </tr>
                  );
                })
              }
            </tbody>
          </table>
        </div>
      </section>
    </div>
  </section>
</Main>

<script>
  const tbody = document.getElementById("suite-summary-body");
  if (tbody) {
    const buttons = Array.from(
      document.querySelectorAll<HTMLButtonElement>("[data-sort-key]"),
    );
    let activeKey = "";
    let direction: "desc" | "asc" = "desc";

    const sortRows = (key: string) => {
      if (activeKey === key) {
        direction = direction === "desc" ? "asc" : "desc";
      } else {
        activeKey = key;
        direction = "desc";
      }

      const rows = Array.from(tbody.querySelectorAll("tr"));
      rows.sort((a, b) => {
        const aValue = Number(a.dataset[key] ?? -1);
        const bValue = Number(b.dataset[key] ?? -1);
        return direction === "desc" ? bValue - aValue : aValue - bValue;
      });

      rows.forEach((row, index) => {
        const rankCell = row.querySelector("th");
        if (rankCell) rankCell.textContent = String(index + 1);
        tbody.appendChild(row);
      });

      buttons.forEach((button) => {
        const isActive = button.dataset.sortKey === activeKey;
        const arrow = isActive ? (direction === "desc" ? " ↓" : " ↑") : "";
        const label = button.dataset.label || "";
        button.textContent = `${label}${arrow}`;
      });
    };

    buttons.forEach((button) => {
      button.addEventListener("click", () => {
        const key = button.dataset.sortKey;
        if (key) sortRows(key);
      });
    });
  }
</script>
