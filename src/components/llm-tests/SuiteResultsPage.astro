---
import Main from "../../layouts/Main.astro";
import MermaidChart from "../MermaidChart";
import { HugeiconsIcon } from "@hugeicons/react";
import {
  StarHalfIcon,
  StarIcon,
  StarOffIcon,
} from "@hugeicons/core-free-icons";
import { FAILSAFE_SCHEMA, load } from "js-yaml";
import { codeToHtml } from "shiki";
import { marked } from "marked";
import {
  LATENCY_NORMALIZED_SCORE_SCALE,
  LATENCY_STEP_SCORE_RULES,
  calculateWindowLatencyMicros,
  summarizeLatencyScore,
} from "../../utils/llm-tests/latency";
import { sumStepScores } from "../../utils/llm-tests/scoring";
import { toYouTubeEmbedUrl } from "../../utils/llm-tests/media";

type Props = {
  pageTitle: string;
  pageDescription: string;
  backHref: string;
  fallbackSuiteName: string;
  resultsYaml: string;
  summaryText?: string;
};

type ParsedTask = {
  id: number;
  name: string;
  chain: string;
  model: string;
  outputFormat: string;
  score: number | null;
  insertedAtRaw: string;
  updatedAtRaw: string;
  outputRaw: string;
  remarkRaw: string;
};

type ParsedTurn = {
  turn: number;
  message: string;
  tasks: ParsedTask[];
};

type ParsedResultsDocument = {
  suite: string;
  youtubeEmbedUrl: string | null;
  turns: ParsedTurn[];
};

type ParsedTimestamp = {
  epochMilliseconds: number;
  epochMicroseconds: number;
};

type TaskTiming = ParsedTask & {
  start: ParsedTimestamp;
  end: ParsedTimestamp;
  durationMicros: number;
  durationMs: string;
};

type StepOutput = TaskTiming & {
  outputHtml: string | null;
  outputQuoteHtml: string | null;
  remarkHtml: string | null;
};

const {
  pageTitle,
  pageDescription,
  backHref,
  fallbackSuiteName,
  resultsYaml,
  summaryText,
} = Astro.props as Props;

function normalizeScore(value: unknown): number | null {
  if (value === null || value === undefined) return null;
  const normalized = String(value).trim().toLowerCase();
  if (normalized.length === 0) return null;
  if (normalized === "pass") return 2;
  if (normalized === "partial") return 1;
  if (normalized === "fail") return 0;
  if (normalized === "0" || normalized === "1" || normalized === "2") {
    return Number(normalized);
  }
  return null;
}

function normalizeTask(rawTask: Record<string, unknown>): ParsedTask {
  return {
    id: Number(rawTask.id ?? 0),
    name: String(rawTask.name ?? ""),
    chain: String(rawTask.chain ?? ""),
    model: String(rawTask.model ?? ""),
    outputFormat: String(rawTask.output_format ?? ""),
    score: normalizeScore(rawTask.score ?? rawTask.result),
    insertedAtRaw: String(rawTask.inserted_at ?? ""),
    updatedAtRaw: String(rawTask.updated_at ?? ""),
    outputRaw: String(rawTask.output ?? ""),
    remarkRaw: String(rawTask.remark ?? ""),
  };
}

function parseTurns(parsed: Record<string, unknown>): ParsedTurn[] {
  if (Array.isArray(parsed.turns)) {
    return parsed.turns
      .map((rawTurn, index) => {
        const turnRecord =
          rawTurn && typeof rawTurn === "object"
            ? (rawTurn as Record<string, unknown>)
            : {};

        const tasks = Array.isArray(turnRecord.tasks)
          ? turnRecord.tasks
              .filter(
                (task): task is Record<string, unknown> =>
                  Boolean(task) && typeof task === "object",
              )
              .map(normalizeTask)
          : [];

        return {
          turn: Number(turnRecord.turn ?? index + 1),
          message: String(turnRecord.message ?? ""),
          tasks,
        };
      })
      .sort((a, b) => a.turn - b.turn);
  }

  const legacyTasks = Array.isArray(parsed.tasks)
    ? parsed.tasks
        .filter(
          (task): task is Record<string, unknown> =>
            Boolean(task) && typeof task === "object",
        )
        .map(normalizeTask)
    : [];

  return [
    {
      turn: Number(parsed.turn ?? 1),
      message: String(parsed.message ?? ""),
      tasks: legacyTasks,
    },
  ];
}

function parseResultsDocument(yamlText: string): ParsedResultsDocument {
  const parsed = load(yamlText, { schema: FAILSAFE_SCHEMA }) as
    | Record<string, unknown>
    | undefined;
  if (!parsed || typeof parsed !== "object") {
    return {
      suite: "",
      youtubeEmbedUrl: null,
      turns: [],
    };
  }

  const youtubeRaw = String(parsed.youtube ?? "").trim();

  return {
    suite: String(parsed.suite ?? ""),
    youtubeEmbedUrl: youtubeRaw ? toYouTubeEmbedUrl(youtubeRaw) : null,
    turns: parseTurns(parsed),
  };
}

function parseTimestampMicros(value: string) {
  const match = value.match(
    /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?$/,
  );
  if (!match) return null;

  const [, year, month, day, hour, minute, second, fraction = "0"] = match;
  const micros = Number(`${fraction}000000`.slice(0, 6));
  const milliseconds = Math.floor(micros / 1000);
  const remainingMicros = micros % 1000;

  const epochMilliseconds = new Date(
    Number(year),
    Number(month) - 1,
    Number(day),
    Number(hour),
    Number(minute),
    Number(second),
    Number(milliseconds),
  ).getTime();

  return {
    epochMilliseconds,
    epochMicroseconds: epochMilliseconds * 1000 + remainingMicros,
  };
}

function formatDurationMs(durationMicros: number) {
  return (durationMicros / 1000).toFixed(3);
}

function averageAcrossTurns(values: number[], totalTurns: number) {
  if (totalTurns <= 0) return null;
  const total = values.reduce((sum, value) => sum + value, 0);
  return Number((total / totalTurns).toFixed(1));
}

function formatOverallScore(value: number | null) {
  if (value === null) return "-";
  return value.toFixed(1);
}

function normalizeEscapedNewlines(value: string) {
  return value.replace(/\\n/g, "\n");
}

async function renderTaskOutput(task: TaskTiming): Promise<StepOutput> {
  const raw = task.outputRaw.trim();
  const outputFormat = task.outputFormat || "";
  const remarkMarkdown = normalizeEscapedNewlines(task.remarkRaw.trim());
  const remarkHtml = remarkMarkdown.length
    ? await marked.parse(remarkMarkdown)
    : null;

  if (outputFormat === "markdown_quote") {
    const markdown = normalizeEscapedNewlines(raw);
    const quotedMarkdown = markdown
      .split("\n")
      .map((line) => `> ${line}`)
      .join("\n");
    const outputQuoteHtml = await marked.parse(quotedMarkdown);

    return {
      ...task,
      outputHtml: null,
      outputQuoteHtml,
      remarkHtml,
    };
  }

  const isJsonLike =
    outputFormat === "json" || raw.startsWith("{") || raw.startsWith("[");
  let source = raw;

  if (isJsonLike) {
    try {
      source = JSON.stringify(JSON.parse(raw), null, 2);
    } catch {
      source = raw;
    }
  }

  const html = await codeToHtml(source, {
    lang: outputFormat === "text" ? "text" : isJsonLike ? "json" : "text",
    theme: "material-theme-ocean",
  });

  return {
    ...task,
    outputHtml: html,
    outputQuoteHtml: null,
    remarkHtml,
  };
}

async function buildTurnView(turnData: ParsedTurn) {
  const tasks = [...turnData.tasks].sort((a, b) => a.id - b.id);

  const taskTimings = tasks
    .map((task) => {
      const start = parseTimestampMicros(task.insertedAtRaw);
      const end = parseTimestampMicros(task.updatedAtRaw);
      if (!start || !end) return null;

      const durationMicros = Math.max(
        end.epochMicroseconds - start.epochMicroseconds,
        1,
      );

      return {
        ...task,
        start,
        end,
        durationMicros,
        durationMs: formatDurationMs(durationMicros),
      };
    })
    .filter((task): task is TaskTiming => Boolean(task));

  const userWaitingTasks = taskTimings.filter(
    (task) => task.id >= 1 && task.id <= 4,
  );
  const postResponseTasks = taskTimings.filter((task) => task.id > 4);
  const beforeResponseLatencyMicros =
    calculateWindowLatencyMicros(userWaitingTasks);
  const beforeResponseLatencyMs =
    beforeResponseLatencyMicros !== null
      ? formatDurationMs(beforeResponseLatencyMicros)
      : null;
  const latencyScoreSummary = summarizeLatencyScore(userWaitingTasks);
  const outputScoreSummary = sumStepScores(taskTimings, {
    fromStep: 1,
    toStep: 5,
  });

  const slowestUserWaitingTask = userWaitingTasks.reduce<TaskTiming | null>(
    (slowest, task) => {
      if (!slowest) return task;
      return task.durationMicros > slowest.durationMicros ? task : slowest;
    },
    null,
  );

  const slowestUserWaitingSharePct =
    beforeResponseLatencyMicros && slowestUserWaitingTask
      ? (
          (slowestUserWaitingTask.durationMicros /
            beforeResponseLatencyMicros) *
          100
        ).toFixed(1)
      : null;

  const chainOrder = [
    ...new Set(taskTimings.map((task) => task.chain || "Uncategorized")),
  ];
  const sections = chainOrder
    .map((chain) => {
      const sectionTasks = taskTimings
        .filter((task) => (task.chain || "Uncategorized") === chain)
        .map((task) => {
          const status =
            task.score === 2 ? "done" : task.score === 1 ? "active" : "crit";
          const label = `${task.id}. ${task.name} (${task.durationMs}ms)`;
          return `    ${label} :${status}, task-${task.id}, ${task.start.epochMilliseconds}, ${task.durationMs}ms`;
        })
        .filter((line): line is string => Boolean(line));

      if (!sectionTasks.length) return null;
      return [`    section ${chain}`, ...sectionTasks].join("\n");
    })
    .filter((section): section is string => Boolean(section));

  const mermaidGantt = sections.length
    ? [
        "gantt",
        `    title ${parsedResults.suite || fallbackSuiteName} Task Timings (Turn ${turnData.turn})`,
        "    dateFormat x",
        "    axisFormat %H:%M:%S.%L",
        ...sections,
      ].join("\n")
    : null;

  const stepOutputs = await Promise.all(taskTimings.map(renderTaskOutput));

  return {
    turn: turnData.turn,
    message: turnData.message,
    taskTimings,
    userWaitingTasks,
    postResponseTasks,
    beforeResponseLatencyMs,
    latencyScoreSummary,
    outputScoreSummary,
    slowestUserWaitingTask,
    slowestUserWaitingSharePct,
    mermaidGantt,
    stepOutputs,
  };
}

const parsedResults = parseResultsDocument(resultsYaml);
const turnViews = await Promise.all(parsedResults.turns.map(buildTurnView));
const outputScores = parsedResults.turns
  .map((turn) => {
    const tasks = [...turn.tasks].sort((a, b) => a.id - b.id);
    const outputScopeTasks = tasks.filter(
      (task) => task.id >= 1 && task.id <= 5,
    );
    const hasAllOutputScores = [1, 2, 3, 4, 5].every((id) =>
      outputScopeTasks.some(
        (task) => task.id === id && typeof task.score === "number",
      ),
    );

    if (!hasAllOutputScores) return null;
    return sumStepScores(outputScopeTasks, {
      fromStep: 1,
      toStep: 5,
    }).total;
  })
  .filter((score): score is number => typeof score === "number");
const latencyScores = turnViews
  .map((turnView) => turnView.latencyScoreSummary?.normalizedScore ?? null)
  .filter((score): score is number => typeof score === "number");
const totalTurns = parsedResults.turns.length;
const overallOutputScore = averageAcrossTurns(outputScores, totalTurns);
const overallLatencyScore = averageAcrossTurns(latencyScores, totalTurns);
---

<Main title={pageTitle} description={pageDescription}>
  <div class="mx-auto flex w-full flex-col items-center px-6 pt-12 lg:pt-16">
    <a href="/" class="inline-flex">
      <img class="h-12 w-auto" src="/instellar-logo.png" alt="Upmaru" />
    </a>
    <p class="mt-2 text-xl font-semibold tracking-tight sm:text-2xl">Upmaru</p>
  </div>
  <section class="mx-auto max-w-4xl px-6 pb-20 pt-10 lg:pb-28 lg:pt-12">
    <a
      href={backHref}
      class="text-sm font-semibold text-primary hover:underline"
      >&larr; Back to Test Run</a
    >
    <h1 class="mt-4 text-4xl font-bold tracking-tight sm:text-5xl">
      {parsedResults.suite || fallbackSuiteName}
    </h1>
    <p class="mt-3 text-base-content/70">
      {
        summaryText ||
          `Output and timing analysis for the ${parsedResults.suite || fallbackSuiteName} suite in the agentic workflow.`
      }
    </p>
    {
      parsedResults.youtubeEmbedUrl && (
        <div class="mt-8">
          <h2 class="text-xl font-semibold">Run Recording</h2>
          <div class="mt-3 overflow-hidden rounded-box border border-base-300 bg-base-100">
            <div class="aspect-video w-full">
              <iframe
                class="h-full w-full"
                src={parsedResults.youtubeEmbedUrl}
                title={`${parsedResults.suite || "Result"} YouTube recording`}
                loading="lazy"
                referrerpolicy="strict-origin-when-cross-origin"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                allowfullscreen
              />
            </div>
          </div>
        </div>
      )
    }

    {
      turnViews.length > 0 ? (
        <div class="mt-10 space-y-14">
          {turnViews.map((turnView, index) => (
            <>
              {index > 0 && <div class="divider">Turn {turnView.turn}</div>}
              <section>
                <div>
                  <h2 class="text-2xl font-semibold">Turn {turnView.turn}</h2>
                  {turnView.message && (
                    <blockquote class="mt-3 border-l-4 border-primary pl-4 italic text-base-content/75">
                      {turnView.message}
                    </blockquote>
                  )}
                </div>

                <div class="mt-6">
                  <h3 class="text-xl font-semibold">Timings</h3>
                  <p class="mt-2 text-base-content/75">
                    Task timeline generated from the recorded{" "}
                    <code>inserted_at</code> and <code>updated_at</code>{" "}
                    timestamps.
                  </p>

                  {turnView.mermaidGantt ? (
                    <div class="relative left-1/2 right-1/2 mt-6 -mx-[50vw] w-screen border-y border-base-300 bg-base-100 py-6">
                      <div class="mx-auto w-full max-w-[1400px] px-6">
                        <MermaidChart
                          chart={turnView.mermaidGantt}
                          className="suite-results-gantt"
                          client:only="react"
                        />
                      </div>
                    </div>
                  ) : (
                    <p class="mt-4 text-sm text-base-content/70">
                      No timed tasks recorded for this turn.
                    </p>
                  )}

                  <div class="mt-6 overflow-x-auto">
                    <table class="table table-zebra">
                      <thead>
                        <tr>
                          <th>ID</th>
                          <th>Task</th>
                          <th>Model</th>
                          <th>Chain</th>
                          <th>Inserted At</th>
                          <th>Updated At</th>
                          <th>Duration (ms)</th>
                        </tr>
                      </thead>
                      <tbody>
                        {turnView.taskTimings.length > 0 ? (
                          [
                            <tr class="bg-base-200/40">
                              <th colspan="7" class="text-left">
                                User Waiting
                                {turnView.beforeResponseLatencyMs && (
                                  <span class="ml-2 font-normal text-base-content/80">
                                    latency: {turnView.beforeResponseLatencyMs}
                                    ms
                                  </span>
                                )}
                              </th>
                            </tr>,
                            ...turnView.userWaitingTasks.map((task) => (
                              <tr>
                                <td class="font-mono">{task.id}</td>
                                <td>{task.name}</td>
                                <td>{task.model}</td>
                                <td>{task.chain}</td>
                                <td class="font-mono text-xs">
                                  {task.insertedAtRaw}
                                </td>
                                <td class="font-mono text-xs">
                                  {task.updatedAtRaw}
                                </td>
                                <td class="font-mono">{task.durationMs}</td>
                              </tr>
                            )),
                            <tr class="bg-base-200/40">
                              <th colspan="7" class="text-left">
                                After First Response
                              </th>
                            </tr>,
                            ...turnView.postResponseTasks.map((task) => (
                              <tr>
                                <td class="font-mono">{task.id}</td>
                                <td>{task.name}</td>
                                <td>{task.model}</td>
                                <td>{task.chain}</td>
                                <td class="font-mono text-xs">
                                  {task.insertedAtRaw}
                                </td>
                                <td class="font-mono text-xs">
                                  {task.updatedAtRaw}
                                </td>
                                <td class="font-mono">{task.durationMs}</td>
                              </tr>
                            )),
                          ].map((row) => row)
                        ) : (
                          <tr>
                            <td
                              colspan="7"
                              class="text-center text-sm text-base-content/70"
                            >
                              No tasks for this turn yet.
                            </td>
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>

                  <div class="mt-4 rounded-box border border-base-300 bg-base-100 p-4">
                    <h3 class="text-lg font-semibold">Quick Analysis</h3>
                    {turnView.beforeResponseLatencyMs &&
                    turnView.slowestUserWaitingTask ? (
                      <p class="mt-2 text-sm text-base-content/80">
                        Users wait{" "}
                        <strong>{turnView.beforeResponseLatencyMs}ms</strong>{" "}
                        before any response is displayed. The largest
                        contributor in the waiting path is{" "}
                        <strong>{turnView.slowestUserWaitingTask.name}</strong>{" "}
                        at{" "}
                        <strong>
                          {turnView.slowestUserWaitingTask.durationMs}ms
                        </strong>
                        {turnView.slowestUserWaitingSharePct && (
                          <span>
                            {" "}
                            ({turnView.slowestUserWaitingSharePct}% of total
                            waiting time)
                          </span>
                        )}
                        .
                      </p>
                    ) : (
                      <p class="mt-2 text-sm text-base-content/80">
                        Timing analysis is unavailable because this turn does
                        not yet include enough timed tasks.
                      </p>
                    )}
                  </div>

                  <div class="stats stats-vertical mt-4 w-full border border-base-300 bg-base-100 lg:stats-horizontal">
                    <div class="stat">
                      <div class="stat-title">Overall Output Score</div>
                      <div class="stat-value text-primary">
                        {turnView.outputScoreSummary.total} /{" "}
                        {turnView.outputScoreSummary.max}
                      </div>
                      <div class="stat-desc">
                        Sum of scores across steps 1-5
                      </div>
                    </div>

                    <div class="stat">
                      <div class="stat-title">Latency Score</div>
                      {turnView.latencyScoreSummary ? (
                        <>
                          <div
                            class:list={[
                              "stat-value",
                              turnView.latencyScoreSummary.normalizedScore >=
                                8 && "text-success",
                              turnView.latencyScoreSummary.normalizedScore >=
                                5 &&
                                turnView.latencyScoreSummary.normalizedScore <
                                  8 &&
                                "text-warning",
                              turnView.latencyScoreSummary.normalizedScore <
                                5 && "text-error",
                            ]}
                          >
                            {turnView.latencyScoreSummary.normalizedScore} /{" "}
                            {LATENCY_NORMALIZED_SCORE_SCALE.max}
                          </div>
                          <div class="stat-desc">
                            latency {turnView.beforeResponseLatencyMs}ms
                          </div>
                          <div class="stat-desc mt-1">
                            per step: &lt;
                            {LATENCY_STEP_SCORE_RULES.fastMs / 1000}s = 2, &lt;
                            {LATENCY_STEP_SCORE_RULES.moderateMs / 1000}s = 1,
                            else = 0
                          </div>
                          <div class="stat-desc mt-1">
                            raw {turnView.latencyScoreSummary.rawTotal} /{" "}
                            {turnView.latencyScoreSummary.rawMax} across{" "}
                            {turnView.latencyScoreSummary.stepCount} steps
                          </div>
                        </>
                      ) : (
                        <>
                          <div class="stat-value text-base-content/40">-</div>
                          <div class="stat-desc">
                            Not enough timing data for user waiting window
                          </div>
                        </>
                      )}
                    </div>
                  </div>

                  <div class="mt-6">
                    <h3 class="text-xl font-semibold">Step Outputs</h3>
                    {turnView.stepOutputs.length > 0 ? (
                      <div class="mt-4 divide-y divide-base-300">
                        {turnView.stepOutputs.map((task) => (
                          <article class="py-5 first:pt-0 last:pb-0">
                            <h4 class="flex items-center justify-between gap-3 text-base font-semibold">
                              <span class="min-w-0">
                                {task.id}. {task.name}{" "}
                                <span class="text-base-content/70">
                                  ({task.model})
                                </span>
                              </span>
                              {task.score === 2 ? (
                                <span
                                  class="text-success"
                                  role="img"
                                  aria-label="Score 2"
                                  title="Score: 2"
                                >
                                  <HugeiconsIcon
                                    icon={StarIcon}
                                    size={20}
                                    strokeWidth={1.8}
                                  />
                                </span>
                              ) : task.score === 1 ? (
                                <span
                                  class="text-warning"
                                  role="img"
                                  aria-label="Score 1"
                                  title="Score: 1"
                                >
                                  <HugeiconsIcon
                                    icon={StarHalfIcon}
                                    size={20}
                                    strokeWidth={1.8}
                                  />
                                </span>
                              ) : task.score === 0 ? (
                                <span
                                  class="text-error"
                                  role="img"
                                  aria-label="Score 0"
                                  title="Score: 0"
                                >
                                  <HugeiconsIcon
                                    icon={StarOffIcon}
                                    size={20}
                                    strokeWidth={1.8}
                                  />
                                </span>
                              ) : (
                                <span
                                  class="text-base-content/40"
                                  role="img"
                                  aria-label="Score not set"
                                  title="Score not set"
                                >
                                  <HugeiconsIcon
                                    icon={StarOffIcon}
                                    size={20}
                                    strokeWidth={1.8}
                                  />
                                </span>
                              )}
                            </h4>
                            <p class="mt-1 text-sm text-base-content/75">
                              {task.chain}
                            </p>
                            {task.outputQuoteHtml ? (
                              <div
                                class="step-output-quote prose prose-invert mt-3 max-w-none"
                                set:html={task.outputQuoteHtml}
                              />
                            ) : (
                              <div
                                class="step-output mt-3 overflow-x-auto"
                                set:html={task.outputHtml}
                              />
                            )}
                            {task.remarkHtml && (
                              <div
                                role="alert"
                                class="alert alert-warning alert-soft mt-3 items-start"
                              >
                                <div class="w-full">
                                  <p class="font-semibold">Remark</p>
                                  <div
                                    class="step-remark mt-1"
                                    set:html={task.remarkHtml}
                                  />
                                </div>
                              </div>
                            )}
                          </article>
                        ))}
                      </div>
                    ) : (
                      <p class="mt-3 text-sm text-base-content/70">
                        No step outputs for this turn yet.
                      </p>
                    )}
                  </div>
                </div>
              </section>
            </>
          ))}

          <div class="divider">Overall Scores</div>
          <section>
            <h2 class="text-2xl font-semibold">Suite-Level Summary</h2>
            <p class="mt-2 text-base-content/75">
              Aggregate scores across all recorded turns in this suite.
            </p>

            <div class="stats stats-vertical mt-4 w-full border border-base-300 bg-base-100 lg:stats-horizontal">
              <div class="stat">
                <div class="stat-title">Overall Output Score (Avg)</div>
                <div class="stat-value text-primary">
                  {formatOverallScore(overallOutputScore)} / 10
                </div>
                <div class="stat-desc">
                  {outputScores.length} of {parsedResults.turns.length} turns
                  scored (missing turns counted as 0)
                </div>
              </div>

              <div class="stat">
                <div class="stat-title">Overall Latency Score (Avg)</div>
                <div
                  class:list={[
                    "stat-value",
                    overallLatencyScore === null && "text-base-content/40",
                    overallLatencyScore !== null &&
                      overallLatencyScore >= 8 &&
                      "text-success",
                    overallLatencyScore !== null &&
                      overallLatencyScore >= 5 &&
                      overallLatencyScore < 8 &&
                      "text-warning",
                    overallLatencyScore !== null &&
                      overallLatencyScore < 5 &&
                      "text-error",
                  ]}
                >
                  {overallLatencyScore === null
                    ? "-"
                    : `${formatOverallScore(overallLatencyScore)} / ${LATENCY_NORMALIZED_SCORE_SCALE.max}`}
                </div>
                <div class="stat-desc">
                  {latencyScores.length} of {turnViews.length} turns with
                  latency data (missing turns counted as 0)
                </div>
              </div>
            </div>
          </section>
        </div>
      ) : (
        <p class="mt-10 text-base-content/70">
          No result turns were found in <code>results.yml</code>.
        </p>
      )
    }
  </section>
</Main>

<style is:global>
  .suite-results-gantt {
    margin: 0;
    overflow-x: auto;
  }

  .suite-results-gantt svg {
    display: block;
    width: 100%;
    height: auto;
  }

  .step-output pre.shiki {
    margin: 0;
    border-radius: 0.75rem;
    border: 1px solid var(--color-base-300);
    padding: 0.875rem 1rem;
  }

  .step-output-quote blockquote {
    margin: 0;
    border-left: 4px solid var(--color-primary);
    background: color-mix(in oklab, var(--color-base-100) 92%, transparent);
    border-radius: 0.5rem;
    padding: 0.875rem 1rem;
  }

  .step-remark :where(p) {
    margin: 0.5rem 0;
  }

  .step-remark :where(ul, ol) {
    margin: 0.25rem 0;
    padding-left: 1.25rem;
  }

  .step-remark :where(code) {
    background: color-mix(in oklab, currentColor 12%, transparent);
    padding: 0.1rem 0.3rem;
    border-radius: 0.25rem;
  }
</style>
